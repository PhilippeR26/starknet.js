"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[8611],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),h=r,k=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return n?a.createElement(k,s(s({ref:t},p),{},{components:n})):a.createElement(k,s({ref:t},p))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},36722:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_position:12},s="Events",i={unversionedId:"guides/events",id:"guides/events",title:"Events",description:"A contract may emit events throughout its execution. Each event contains the following fields:",source:"@site/docs/guides/events.md",sourceDirName:"guides",slug:"/guides/events",permalink:"/starknet.js/docs/next/guides/events",draft:!1,tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"defaultSidebar",previous:{title:"Work with ERC20 tokens",permalink:"/starknet.js/docs/next/guides/use_ERC20"},next:{title:"Messages with L1 network",permalink:"/starknet.js/docs/next/guides/L1message"}},l={},c=[{value:"Why events ?",id:"why-events-",level:2},{value:"With the Transaction hash",id:"with-the-transaction-hash",level:2},{value:"Raw response",id:"raw-response",level:3},{value:"Parsed response",id:"parsed-response",level:3},{value:"Without transaction hash",id:"without-transaction-hash",level:2}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"events"},"Events"),(0,r.kt)("p",null,"A contract may emit events throughout its execution. Each event contains the following fields:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"from_address: address of the contract emitting the events"),(0,r.kt)("li",{parentName:"ul"},"keys: a list of field elements"),(0,r.kt)("li",{parentName:"ul"},"data: a list of field elements")),(0,r.kt)("p",null,"The keys can be used for indexing the events, while the data may contain any information that we wish to log."),(0,r.kt)("p",null,"The events are recorded in the blocks of the blockchain."),(0,r.kt)("p",null,"Example of Cairo code for an event:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Drop, starknet::Event)]\n    struct EventPanic {\n        #[key]\n        errorType: u8,\n        errorDescription: felt252,\n    }\n")),(0,r.kt)("p",null,"Here we have an event called ",(0,r.kt)("inlineCode",{parentName:"p"},"EventPanic"),", with an u8 stored in keys, and a felt252 (text) in data."),(0,r.kt)("h2",{id:"why-events-"},"Why events ?"),(0,r.kt)("p",null,"Events are a useful tool for logging and notifying external entities about specific occurrences within a contract, with a timestamp (the block number). They emit data that can be accessed by everybody."),(0,r.kt)("p",null,"Some cases:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When a specific value is reached in a contract, an event can be created to store the fact that this value has been reached at a specific block number."),(0,r.kt)("li",{parentName:"ul"},"When the L1 network has triggered the execution of a L2 contract, you can store in the event some results and when it occurs.")),(0,r.kt)("p",null,"An event can be useful also when you invoke a contract. When you invoke a Cairo function (meaning to write in the network), the API does not authorize any response (only call functions can provide an answer). To generate an event in the code is a way to provide a response (for example for the creation of an account, an event is generated to return the account address)."),(0,r.kt)("h2",{id:"with-the-transaction-hash"},"With the Transaction hash"),(0,r.kt)("p",null,"If you use Starknet.js to invoke a Cairo function that will trigger a new event, you will receive the transaction hash as a response. Preserve it so it can be used to easily retrieve the event data."),(0,r.kt)("p",null,"Example of invocation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const transactionHash = myContract.invoke("emitEventPanic", [8, "Mega Panic."])\n')),(0,r.kt)("p",null,"Then get the transaction receipt:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const txReceipt = await provider.waitForTransaction(transactionHash);\n")),(0,r.kt)("h3",{id:"raw-response"},"Raw response"),(0,r.kt)("p",null,"You can recover all the events related to this transaction hash:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const listEvents = txReceipt.events;\n")),(0,r.kt)("p",null,"The result is an array of events (here only one event):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"[\n    {\n        from_address: '0x47cb13bf174043adde61f7bea49ab2d9ebc575b0431f85bcbfa113a6f93fc4',\n        keys: [\n        '0x3ba972537cb2f8e811809bba7623a2119f4f1133ac9e955a53d5a605af72bf2',\n        '0x8'\n        ],\n        data: [ '0x4d6567612050616e69632e' ]\n    }\n]\n")),(0,r.kt)("p",null,"The first parameter in the ",(0,r.kt)("inlineCode",{parentName:"p"},"keys")," array is a hash of the name of the event, calculated this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const nameHash = num.toHex( hash.starknetKeccak("EventPanic"));\n')),(0,r.kt)("p",null,"The second parameter is the ",(0,r.kt)("inlineCode",{parentName:"p"},"errorType")," variable content (stored in keys array because of the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[key]")," flag in the Cairo code)."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," array contains the ",(0,r.kt)("inlineCode",{parentName:"p"},"errorDescription")," variable content (",(0,r.kt)("inlineCode",{parentName:"p"},"'0x4d6567612050616e69632e'"),' corresponds to the encoded value of "Mega Panic.")'),(0,r.kt)("p",null,"You can decode it with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const ErrorMessage =  shortString.decodeShortString("0x4d6567612050616e69632e")\n')),(0,r.kt)("h3",{id:"parsed-response"},"Parsed response"),(0,r.kt)("p",null,"Once you have the transaction receipt, you can parse the events to have something easier to process.",(0,r.kt)("br",{parentName:"p"}),"\n","We will perform parsing this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const events = myTestContract.parseEvents(txReceipt);\n")),(0,r.kt)("p",null,"The result is an array of parsed events (here only one event):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"events = [\n  {\n    EventPanic: { errorType: 8n, errorDescription: 93566154138418073030976302n }\n  },\n]\n")),(0,r.kt)("p",null,"Easier to read and process, isn't it?"),(0,r.kt)("h2",{id:"without-transaction-hash"},"Without transaction hash"),(0,r.kt)("p",null,"If you don't have the transaction Hash of the contract execution that created the event, it will be necessary to search inside the blocks of the Starknet blockchain."),(0,r.kt)("p",null,"In this example, if you want to read the events recorded in the last 10 blocks, you need to use a method available only from an RPC node. The class ",(0,r.kt)("inlineCode",{parentName:"p"},"RpcProvider")," is available for this case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { RpcProvider } from "starknet";\nconst providerRPC = new RpcProvider({ nodeUrl: "{ nodeUrl: \'https://starknet-goerli.infura.io/v3/\' + infuraKey }" }); // for an Infura node on Testnet\nconst lastBlock = await providerRPC.getBlock(\'latest\');\nconst keyFilter = [num.toHex(hash.starknetKeccak("EventPanic")), "0x8"]\nconst eventsList = await providerRPC.getEvents({\n    address: myContractAddress,\n    from_block: {block_number: lastBlock.block_number-9},\n    to_block: {block_number: lastBlock.block_number},\n    keys:[keyFilter],\n    chunk_size: 10\n});\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"address, from_block, to_block, keys")," are all optional parameters.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If you don't want to filter by key, you can either remove the ",(0,r.kt)("inlineCode",{parentName:"p"},"keys")," parameter, or affect it this way: ",(0,r.kt)("inlineCode",{parentName:"p"},"[[]]")," .")),(0,r.kt)("p",null,"Here we have only one event. You can easily read this event:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const event = eventsList.events[0];\nconsole.log("data length =", event.data.length, "key length =", event.keys.length, ":");\nconsole.log("\\nkeys =", event.keys, "data =", event.data);\n')),(0,r.kt)("p",null,"To limit the workload of the node, the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"chunk_size")," defines a size of chunk to read. If the request needs an additional chunk, the response includes a key ",(0,r.kt)("inlineCode",{parentName:"p"},"continuation_token")," containing a string to use in the next request.",(0,r.kt)("br",{parentName:"p"}),"\n","Hereunder a code to read all the chunks of a request:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const keyFilter = [num.toHex(hash.starknetKeccak("EventPanic")), "0x8"]\nlet block = await provider.getBlock(\'latest\');\nconsole.log("bloc #", block.block_number);\n\nlet continuationToken: string | undefined = "0";\nlet chunkNum: number = 1;\nwhile (continuationToken) {\n    const eventsRes = await providerRPC.getEvents({\n        from_block: {\n            block_number: block.block_number - 30\n        },\n        to_block: {\n            block_number: block.block_number\n        },\n        address: myContractAddress,\n        keys: [keyFilter],\n        chunk_size: 5,\n        continuation_token: continuationToken\n    });\n    const nbEvents = eventsRes.events.length;\n    continuationToken=eventsRes.continuation_token;\n    console.log("chunk nb =", chunkNum, ".", nbEvents, "events recovered.");\n    console.log("continuation_token =", continuationToken );\n    for (let i = 0; i < nbEvents; i++) {\n        const event = eventsRes.events[i];\n        console.log("event #", i, "data length =", event.data.length, "key length =", event.keys.length, ":");\n        console.log("\\nkeys =", event.keys, "data =", event.data)\n    }\n    chunkNum++;\n}\n')))}d.isMDXComponent=!0}}]);