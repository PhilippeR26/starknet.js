"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[53689],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),c=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},p=function(t){var e=c(t.components);return a.createElement(s.Provider,{value:e},t.children)},d="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,s=t.parentName,p=i(t,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(h,l(l({ref:e},p),{},{components:n})):a.createElement(h,l({ref:e},p))}));function h(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var s in e)hasOwnProperty.call(e,s)&&(i[s]=e[s]);i.originalType=t,i[d]="string"==typeof t?t:r,l[1]=i;for(var c=2;c<o;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},51295:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_position:4},l="Contract",i={unversionedId:"guides/Old_API_doc/contract",id:"version-5.19.5/guides/Old_API_doc/contract",title:"Contract",description:"Contracts can do data transformations in JavaScript based on an ABI. They can also call and invoke to Starknet through a provided Signer.",source:"@site/versioned_docs/version-5.19.5/guides/Old_API_doc/contract.md",sourceDirName:"guides/Old_API_doc",slug:"/guides/Old_API_doc/contract",permalink:"/starknet.js/docs/5.19.5/guides/Old_API_doc/contract",draft:!1,tags:[],version:"5.19.5",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"defaultSidebar",previous:{title:"Signer",permalink:"/starknet.js/docs/5.19.5/guides/Old_API_doc/signer"},next:{title:"Contract Factory",permalink:"/starknet.js/docs/5.19.5/guides/Old_API_doc/contractFactory"}},s={},c=[{value:"Creating an instance",id:"creating-an-instance",level:2},{value:"Properties",id:"properties",level:2},{value:"Methods",id:"methods",level:2},{value:"attach()",id:"attach",level:3},{value:"connect()",id:"connect",level:3},{value:"deployed()",id:"deployed",level:3},{value:"call()",id:"call",level:3},{value:"invoke()",id:"invoke",level:3},{value:"estimate()",id:"estimate",level:3},{value:"populate()",id:"populate",level:3},{value:"Meta-Class",id:"meta-class",level:2},{value:"Read-Only Methods(constant)",id:"read-only-methodsconstant",level:3},{value:"Write Methods (non-constant)",id:"write-methods-non-constant",level:3},{value:"Write Methods Analysis",id:"write-methods-analysis",level:3}],p={toc:c},d="wrapper";function u(t){let{components:e,...n}=t;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"contract"},"Contract"),(0,r.kt)("p",null,"Contracts can do data transformations in JavaScript based on an ABI. They can also call and invoke to Starknet through a provided Signer."),(0,r.kt)("p",null,"Contracts allow you to transform Cairo values, like ",(0,r.kt)("inlineCode",{parentName:"p"},"Uint256")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"BigNumber"),". It could also allow users to pass their own transformers, similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON.parse"),"."),(0,r.kt)("h2",{id:"creating-an-instance"},"Creating an instance"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"new starknet.Contract(abi, address, providerOrAccount)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"contract.attach(address)")," ",(0,r.kt)("em",{parentName:"p"},"for changing the address of the connected contract")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"contract.connect(providerOrAccount)")," ",(0,r.kt)("em",{parentName:"p"},"for changing the provider or account")),(0,r.kt)("h2",{id:"properties"},"Properties"),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"abi")," => ",(0,r.kt)("em",{parentName:"p"},"Abi")),(0,r.kt)("p",null,"The ABI the contract was constructed with."),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"address")," => ",(0,r.kt)("em",{parentName:"p"},"string")),(0,r.kt)("p",null,"The address the contract was constructed/connected with."),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"providerOrAccount")," => ",(0,r.kt)("em",{parentName:"p"},"ProviderInterface | AccountInterface")),(0,r.kt)("p",null,"Provider or account that are used to interact with the network."),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"deployTransactionHash")," => ",(0,r.kt)("em",{parentName:"p"},"string | null")),(0,r.kt)("p",null,"If the Contract object is the result of a ContractFactory deployment, this is the transaction which was used to deploy the contract."),(0,r.kt)("h2",{id:"methods"},"Methods"),(0,r.kt)("h3",{id:"attach"},"attach()"),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"attach"),"(address) => void"),(0,r.kt)("p",null,"Saves the address of the contract deployed on network that will be used for interaction."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"address")," - address of the contract."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"connect"},"connect()"),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"connect"),"(providerOrAccount) => void"),(0,r.kt)("p",null,"Attaches to new Provider or Account"),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"deployed"},"deployed()"),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"deployed"),"() => ",(0,r.kt)("em",{parentName:"p"},"Promise < Contract >")),(0,r.kt)("p",null,"If the Contract object is the result of a ContractFactory deployment, this method will wait for the transaction to be resolved."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"call"},"call()"),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"call"),"(method, args, options) => ",(0,r.kt)("em",{parentName:"p"},"Promise < Result >")),(0,r.kt)("p",null,"Calls a method on a contract."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"invoke"},"invoke()"),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"invoke"),"(method, args, options) => ",(0,r.kt)("em",{parentName:"p"},"Promise < InvokeFunctionResponse >")),(0,r.kt)("p",null,"Invokes a method on a contract."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"estimate"},"estimate()"),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"estimate"),"(method, args, options) => ",(0,r.kt)("em",{parentName:"p"},"Promise < any >")),(0,r.kt)("p",null,"Estimates a method on a contract."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"populate"},"populate()"),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"populate"),"(method, args, options) => ",(0,r.kt)("em",{parentName:"p"},"Invocation")),(0,r.kt)("h2",{id:"meta-class"},"Meta-Class"),(0,r.kt)("p",null,"A Meta-Class is a Class which has any of its properties determined at run-time. The Contract object uses a Contract's ABI to determine what methods are available, so the following sections describe the generic ways to interact with the properties added at run-time during the Contract constructor."),(0,r.kt)("h3",{id:"read-only-methodsconstant"},"Read-Only Methods(constant)"),(0,r.kt)("p",null,"A constant method (denoted view in Cairo) is read-only and evaluates a small amount of Cairo code against the current blockchain state. It is therefore free and does not require any fee, but cannot make changes to the blockchain state..."),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"METHOD_NAME"),"(...args ","[ , overrides ]",") => ",(0,r.kt)("em",{parentName:"p"},"Promise < Result >")),(0,r.kt)("p",null,"The type of the result depends on the ABI. Result object will be returned with each parameter available positionally and if the parameter is named, it will also be available by its name."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"overrides")," object for a read-only method may include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"overrides.",(0,r.kt)("strong",{parentName:"li"},"blockIdentifier"))),(0,r.kt)("h3",{id:"write-methods-non-constant"},"Write Methods (non-constant)"),(0,r.kt)("p",null,"A non-constant method requires a transaction to be signed and requires payment in the form of a fee to be paid."),(0,r.kt)("p",null,"contract.",(0,r.kt)("strong",{parentName:"p"},"METHOD_NAME"),"(...args ","[ , overrides ]",") => ",(0,r.kt)("em",{parentName:"p"},"Promise < AddTransactionResponse >")),(0,r.kt)("p",null,"Returns a ",(0,r.kt)("em",{parentName:"p"},"AddTransactionResponse")," for the transaction after it is sent to the network. This requires that Contract has a signer."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"overrides")," object for write methods may include any of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"overrides.",(0,r.kt)("strong",{parentName:"li"},"signature")," - Signature that will be used for the transaction"),(0,r.kt)("li",{parentName:"ul"},"overrides.",(0,r.kt)("strong",{parentName:"li"},"maxFee")," - Max Fee for the transaction"),(0,r.kt)("li",{parentName:"ul"},"overrides.",(0,r.kt)("strong",{parentName:"li"},"nonce")," - Nonce for the transaction")),(0,r.kt)("h3",{id:"write-methods-analysis"},"Write Methods Analysis"),(0,r.kt)("p",null,"There are several options to analyze properties and results of a write method without actually executing it."),(0,r.kt)("p",null,"contract.estimateFee.",(0,r.kt)("strong",{parentName:"p"},"METHOD_NAME"),"( ...args ) => ",(0,r.kt)("em",{parentName:"p"},"Promise < EstimateFeeResponse >")),(0,r.kt)("p",null,"Returns the estimate units of gas that would be required to execute the METHOD_NAME with args and overrides."),(0,r.kt)("p",null,"contract.populateTransaction.",(0,r.kt)("strong",{parentName:"p"},"METHOD_NAME"),"( ...args ","[ , overrides ]"," ) \u21d2 ",(0,r.kt)("em",{parentName:"p"},"Call")),(0,r.kt)("p",null,"Returns an ",(0,r.kt)("em",{parentName:"p"},"Call")," object which represents the transaction that would need to be signed and submitted to the network to execute METHOD_NAME with args and overrides."),(0,r.kt)("p",null,"The overrides are identical to the overrides above for write methods."))}u.isMDXComponent=!0}}]);