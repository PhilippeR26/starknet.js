"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[13523],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>k});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),u=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=u(e.components);return n.createElement(o.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=u(a),m=r,k=p["".concat(o,".").concat(m)]||p[m]||c[m]||i;return a?n.createElement(k,l(l({ref:t},d),{},{components:a})):n.createElement(k,l({ref:t},d))}));function k(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[p]="string"==typeof e?e:r,l[1]=s;for(var u=2;u<i;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},98416:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var n=a(87462),r=(a(67294),a(3905));const i={sidebar_position:6},l="Utils",s={unversionedId:"API/utils",id:"version-4.22.0/API/utils",title:"Utils",description:"Util functions are provided so you can use various low level functions in your application.",source:"@site/versioned_docs/version-4.22.0/API/utils.md",sourceDirName:"API",slug:"/API/utils",permalink:"/starknet.js/docs/4.22.0/API/utils",draft:!1,tags:[],version:"4.22.0",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Contract Factory",permalink:"/starknet.js/docs/4.22.0/API/contractFactory"},next:{title:"CHANGELOG",permalink:"/starknet.js/docs/4.22.0/API/changelog"}},o={},u=[{value:"<strong>address</strong>",id:"address",level:2},{value:"validateAndParseAddress",id:"validateandparseaddress",level:3},{value:"getChecksumAddress",id:"getchecksumaddress",level:3},{value:"validateChecksumAddress",id:"validatechecksumaddress",level:3},{value:"<strong>stark</strong>",id:"stark",level:2},{value:"compressProgram",id:"compressprogram",level:3},{value:"randomAddress",id:"randomaddress",level:3},{value:"makeAddress",id:"makeaddress",level:3},{value:"formatSignature",id:"formatsignature",level:3},{value:"compileCalldata",id:"compilecalldata",level:3},{value:"estimatedFeeToMaxFee",id:"estimatedfeetomaxfee",level:3},{value:"<strong>number</strong>",id:"number",level:2},{value:"isHex",id:"ishex",level:3},{value:"toBN",id:"tobn",level:3},{value:"toHex",id:"tohex",level:3},{value:"cleanHex",id:"cleanhex",level:3},{value:"hexToDecimalString",id:"hextodecimalstring",level:3},{value:"toFelt",id:"tofelt",level:3},{value:"assertInRange",id:"assertinrange",level:3},{value:"bigNumberishArrayToDecimalStringArray",id:"bignumberisharraytodecimalstringarray",level:3},{value:"bigNumberishArrayToHexadecimalStringArray",id:"bignumberisharraytohexadecimalstringarray",level:3},{value:"<strong>uint256</strong>",id:"uint256",level:2},{value:"uint256ToBN",id:"uint256tobn",level:3},{value:"isUint256",id:"isuint256",level:3},{value:"bnToUint256",id:"bntouint256",level:3},{value:"<strong>hash</strong>",id:"hash",level:2},{value:"starknetKeccak",id:"starknetkeccak",level:3},{value:"getSelectorFromName",id:"getselectorfromname",level:3},{value:"pedersen",id:"pedersen",level:3},{value:"computeHashOnElements",id:"computehashonelements",level:3},{value:"calculateTransactionHashCommon",id:"calculatetransactionhashcommon",level:3},{value:"calculateDeployTransactionHash",id:"calculatedeploytransactionhash",level:3},{value:"calculateTransactionHash",id:"calculatetransactionhash",level:3},{value:"calculateContractAddressFromHash",id:"calculatecontractaddressfromhash",level:3},{value:"<strong>ellipticCurve</strong>",id:"ellipticcurve",level:2},{value:"genKeyPair",id:"genkeypair",level:3},{value:"getKeyPair",id:"getkeypair",level:3},{value:"getStarkKey",id:"getstarkkey",level:3},{value:"getKeyPairFromPublicKey",id:"getkeypairfrompublickey",level:3},{value:"sign",id:"sign",level:3},{value:"verify",id:"verify",level:3},{value:"<strong>calldata</strong>",id:"calldata",level:2},{value:"compile",id:"compile",level:3},{value:"validate",id:"validate",level:3}],d={toc:u},p="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"utils"},"Utils"),(0,r.kt)("p",null,"Util functions are provided so you can use various low level functions in your application."),(0,r.kt)("h2",{id:"address"},(0,r.kt)("strong",{parentName:"h2"},"address")),(0,r.kt)("p",null,"Helper functions for starknet addresses."),(0,r.kt)("h3",{id:"validateandparseaddress"},"validateAndParseAddress"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"validateAndParseAddress(address: BigNumberish): string")),(0,r.kt)("p",null,"Checks if the address is valid and, if it is, parses it to the correct format (0x prefix is added if not provided)."),(0,r.kt)("h3",{id:"getchecksumaddress"},"getChecksumAddress"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getChecksumAddress(address: BigNumberish): string")),(0,r.kt)("p",null,"This function accepts an address as a ",(0,r.kt)("inlineCode",{parentName:"p"},"BigNumberish")," and returns the checksummed address as a string.\nAn example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { address } from 'starknet.js';\n\nconst addressToCheck = '0x2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914';\n\nconst checksummedAddress = address.getChecksumAddress(addressToCheck);\n\nconsole.log(checksummedAddress); // 0x02FD23D9182193775423497Fc0c472E156C57C69E4089a1967fb288a2D84e914\n")),(0,r.kt)("h3",{id:"validatechecksumaddress"},"validateChecksumAddress"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"validateChecksumAddress(address: string): boolean")),(0,r.kt)("p",null,"This function validates the checksum address."),(0,r.kt)("p",null,"Returns true if the address is valid, false otherwise."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"stark"},(0,r.kt)("strong",{parentName:"h2"},"stark")),(0,r.kt)("p",null,"Functions for stark specific manipulations."),(0,r.kt)("h3",{id:"compressprogram"},"compressProgram"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"compressProgram(jsonProgram: Program | string): CompressedProgram")),(0,r.kt)("p",null,"Function to compress compiled cairo program. Accepts a json file representing the compiled cairo program and returns a compressed cairo program."),(0,r.kt)("h3",{id:"randomaddress"},"randomAddress"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"randomAddress(): string")),(0,r.kt)("p",null,"Function that generates a random stark address."),(0,r.kt)("h3",{id:"makeaddress"},"makeAddress"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"makeAddress(input: string): string")),(0,r.kt)("p",null,"Function that turns an incompatible address string into stark address format."),(0,r.kt)("p",null,"Returns a string."),(0,r.kt)("p",null,"Example: ",(0,r.kt)("inlineCode",{parentName:"p"},"0xdFD0F27FCe99b50909de0bDD328Aed6eAbe76BC5")," -> ",(0,r.kt)("inlineCode",{parentName:"p"},"0xdfd0f27fce99b50909de0bdd328aed6eabe76bc5")),(0,r.kt)("h3",{id:"formatsignature"},"formatSignature"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"formatSignature(sig?: Signature): string[]")),(0,r.kt)("p",null,"Function that formats a Signature to BigNum and then to string array."),(0,r.kt)("p",null,"Returns a string array."),(0,r.kt)("h3",{id:"compilecalldata"},"compileCalldata"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"compileCalldata(args: RawArgs): Calldata")),(0,r.kt)("p",null,"Function that creates calldata that gets sent to the contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await this.callContract({\n    contractAddress: this.address,\n    entrypoint: 'is_valid_signature',\n    calldata: compileCalldata({\n        hash: toBN(hash).toString(),\n        signature: signature.map((x) => toBN(x).toString()),\n    }),\n});\n")),(0,r.kt)("h3",{id:"estimatedfeetomaxfee"},"estimatedFeeToMaxFee"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"estimatedFeeToMaxFee(estimatedFee: BigNumberish, overhead: number = 0.5): BN")),(0,r.kt)("p",null,"Function that calculates and returns maximum fee based on the previously estimated one."),(0,r.kt)("p",null,"Returns a BN."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"number"},(0,r.kt)("strong",{parentName:"h2"},"number")),(0,r.kt)("p",null,"Various number formatting functions."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BN")," is the ",(0,r.kt)("inlineCode",{parentName:"p"},"BigNum")," representation imported from ",(0,r.kt)("inlineCode",{parentName:"p"},"bn.js")," library."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"export type BigNumberish = string | number | BN;\n")),(0,r.kt)("h3",{id:"ishex"},"isHex"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"isHex(hex: string): boolean")),(0,r.kt)("p",null,"Check if number is in hex format."),(0,r.kt)("h3",{id:"tobn"},"toBN"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"toBN(number: BigNumberish, base?: number | 'hex'): BN")),(0,r.kt)("p",null,"Converts BigNumberish to BN."),(0,r.kt)("p",null,"Returns a BN."),(0,r.kt)("h3",{id:"tohex"},"toHex"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"toHex(number: BN): string")),(0,r.kt)("p",null,"Converts BN to hex."),(0,r.kt)("p",null,"Returns a string."),(0,r.kt)("h3",{id:"cleanhex"},"cleanHex"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"cleanHex(hex: string): string")),(0,r.kt)("p",null,"Remove leading zeroes and lowercase hex string after '0x'"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0x01AFF")," -> ",(0,r.kt)("inlineCode",{parentName:"p"},"0x1aff")),(0,r.kt)("h3",{id:"hextodecimalstring"},"hexToDecimalString"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"hexToDecimalString(hex: string): string")),(0,r.kt)("p",null,"Converts hex string to decimal string."),(0,r.kt)("h3",{id:"tofelt"},"toFelt"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"toFelt(num: BigNumberish): string")),(0,r.kt)("p",null,"Converts BN to Felt."),(0,r.kt)("p",null,"Returns a string."),(0,r.kt)("h3",{id:"assertinrange"},"assertInRange"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"assertInRange(input: BigNumberish, lowerBound: BigNumberish, upperBound: BigNumberish, inputName = '')")),(0,r.kt)("p",null,"Asserts input is equal to or greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"lowerBound")," and lower than ",(0,r.kt)("inlineCode",{parentName:"p"},"upperBound"),". Assert message specifies inputName.\n",(0,r.kt)("inlineCode",{parentName:"p"},"input"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"lowerBound"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"upperBound")," should be of type BN.\n",(0,r.kt)("inlineCode",{parentName:"p"},"inputName")," should be a string."),(0,r.kt)("h3",{id:"bignumberisharraytodecimalstringarray"},"bigNumberishArrayToDecimalStringArray"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"bigNumberishArrayToDecimalStringArray(rawCalldata: BigNumberish[]): string[]")),(0,r.kt)("p",null,"Convert BigNumberish array to decimal array. Used for signature conversion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const signature = await this.signer.signTransaction(transactions, signerDetails);\n\n{\n    contract_address: this.address,\n    entry_point_selector: getSelectorFromName('__execute__'),\n    calldata,\n    version: toHex(version),\n    signature: bigNumberishArrayToDecimalStringArray(signature),\n}\n")),(0,r.kt)("h3",{id:"bignumberisharraytohexadecimalstringarray"},"bigNumberishArrayToHexadecimalStringArray"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"bigNumberishArrayToHexadecimalStringArray(rawCalldata: BigNumberish[]): string[]")),(0,r.kt)("p",null,"Convert BigNumberish array to hexadecimal string array. Used for signature conversion."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"uint256"},(0,r.kt)("strong",{parentName:"h2"},"uint256")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Represents an integer in the range [0, 2^256).\nexport interface Uint256 {\n  // The low 128 bits of the value.\n  low: BigNumberish;\n  // The high 128 bits of the value.\n  high: BigNumberish;\n}\n")),(0,r.kt)("h3",{id:"uint256tobn"},"uint256ToBN"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"uint256ToBN(uint256: Uint256): BN")),(0,r.kt)("p",null,"Function to convert ",(0,r.kt)("inlineCode",{parentName:"p"},"Uint256")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"BN")," (big number), which uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"bn.js")," library."),(0,r.kt)("h3",{id:"isuint256"},"isUint256"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"isUint256(bn: BigNumberish): boolean")),(0,r.kt)("p",null,"Function to check if ",(0,r.kt)("inlineCode",{parentName:"p"},"BN")," is smaller or equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"2**256-1"),"."),(0,r.kt)("h3",{id:"bntouint256"},"bnToUint256"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"bnToUint256(bignumber: BigNumberish): Uint256")),(0,r.kt)("p",null,"Function to convert ",(0,r.kt)("inlineCode",{parentName:"p"},"BN")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Uint256"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"hash"},(0,r.kt)("strong",{parentName:"h2"},"hash")),(0,r.kt)("p",null,"Various hashing helpers."),(0,r.kt)("h3",{id:"starknetkeccak"},"starknetKeccak"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"starknetKeccak(value: string): BN")),(0,r.kt)("p",null,"Function to get the starknet keccak hash from a string. Returns starknet keccak hash as BigNumber."),(0,r.kt)("p",null,"Returns starknet keccak hash as BigNumber."),(0,r.kt)("h3",{id:"getselectorfromname"},"getSelectorFromName"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getSelectorFromName(funcName: string)")),(0,r.kt)("p",null,"Function to get the hex selector from a given function name."),(0,r.kt)("p",null,"Returns hex selector of given abi function name."),(0,r.kt)("h3",{id:"pedersen"},"pedersen"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pedersen(input: [BigNumberish, BigNumberish])")),(0,r.kt)("p",null,"Function to get the Pedersen hash for two arguments."),(0,r.kt)("p",null,"Returns a string."),(0,r.kt)("h3",{id:"computehashonelements"},"computeHashOnElements"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"computeHashOnElements(data: BigNumberish[])")),(0,r.kt)("p",null,"Function to compute a Pedersen hash on an array of elements."),(0,r.kt)("p",null,"Returns a string."),(0,r.kt)("h3",{id:"calculatetransactionhashcommon"},"calculateTransactionHashCommon"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"calculateTransactionHashCommon(txHashPrefix: TransactionHashPrefix, version: BigNumberish, contractAddress: BigNumberish, entryPointSelector: BigNumberish, calldata: BigNumberish[], maxFee: BigNumberish, chainId: StarknetChainId, additionalData: BigNumberish[] = []): string")),(0,r.kt)("p",null,"Calculates the transaction hash in the Starknet network - a unique identifier of the transaction."),(0,r.kt)("p",null,"Called internally in ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateDeployTransactionHash")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateTransactionHash"),"."),(0,r.kt)("h3",{id:"calculatedeploytransactionhash"},"calculateDeployTransactionHash"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"calculateDeployTransactionHash(contractAddress: BigNumberish, constructorCalldata: BigNumberish[], version: BigNumberish, chainId: StarknetChainId): string")),(0,r.kt)("p",null,"Function that calculates the deployment transaction hash in the Starknet network."),(0,r.kt)("p",null,"Internally calls ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateTransactionHashCommon")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"TransactionHashPrefix.DEPLOY"),"."),(0,r.kt)("h3",{id:"calculatetransactionhash"},"calculateTransactionHash"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"calculateTransactionHash(contractAddress: BigNumberish, version: BigNumberish, entryPointSelector: BigNumberish, calldata: BigNumberish[], maxFee: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish): string")),(0,r.kt)("p",null,"Function that internally calls ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateTransactionHashCommon"),", with ",(0,r.kt)("inlineCode",{parentName:"p"},"TransactionHashPrefix.INVOKE"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const hashMsg = calculateTransactionHash(\n  account,\n  transactionVersion,\n  getSelectorFromName('__execute__'),\n  calldata,\n  maxFee,\n  StarknetChainId.TESTNET\n);\n")),(0,r.kt)("h3",{id:"calculatecontractaddressfromhash"},"calculateContractAddressFromHash"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"calculateContractAddressFromHash(salt: BigNumberish, classHash: BigNumberish, constructorCalldata: RawCalldata, deployerAddress: BigNumberish)")),(0,r.kt)("p",null,"Function that calculates contract address from hash."),(0,r.kt)("p",null,"Returns a string."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"ellipticcurve"},(0,r.kt)("strong",{parentName:"h2"},"ellipticCurve")),(0,r.kt)("p",null,"Wrapper around the javascript ",(0,r.kt)("inlineCode",{parentName:"p"},"elliptic")," library with additional functionality."),(0,r.kt)("h3",{id:"genkeypair"},"genKeyPair"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ec.genKeyPair()")),(0,r.kt)("p",null,"Generate a random key pair."),(0,r.kt)("h3",{id:"getkeypair"},"getKeyPair"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getKeyPair(pk: BigNumberish): KeyPair")),(0,r.kt)("p",null,"Get a key pair from a private key."),(0,r.kt)("h3",{id:"getstarkkey"},"getStarkKey"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getStarkKey(keyPair: KeyPair): string")),(0,r.kt)("p",null,"Public key defined over a Stark-friendly elliptic curve that is different from the standard Ethereum elliptic curve"),(0,r.kt)("h3",{id:"getkeypairfrompublickey"},"getKeyPairFromPublicKey"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getKeyPairFromPublicKey(publicKey: BigNumberish): KeyPair")),(0,r.kt)("p",null,"Takes a public key and casts it into ",(0,r.kt)("inlineCode",{parentName:"p"},"elliptic")," KeyPair format."),(0,r.kt)("p",null,"Returns keyPair with public key only, which can be used to verify signatures, but can't sign anything."),(0,r.kt)("h3",{id:"sign"},"sign"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"sign(keyPair: KeyPair, msgHash: string): Signature")),(0,r.kt)("p",null,"Signs a message using the provided key."),(0,r.kt)("p",null,"keyPair should be a KeyPair with a valid private key."),(0,r.kt)("p",null,"Returns a Signature."),(0,r.kt)("h3",{id:"verify"},"verify"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"verify(keyPair: KeyPair | KeyPair[], msgHash: string, sig: Signature): boolean")),(0,r.kt)("p",null,"Verifies a message using the provided key."),(0,r.kt)("p",null,"keyPair should be a KeyPair with a valid public key."),(0,r.kt)("p",null,"sig should be an Signature."),(0,r.kt)("p",null,"Returns true if the verification succeeds."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"calldata"},(0,r.kt)("strong",{parentName:"h2"},"calldata")),(0,r.kt)("p",null,"Functions to compile and validate arguments passed in invoke, call and deploy functions."),(0,r.kt)("h3",{id:"compile"},"compile"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"compileCalldata(args: Array<any>, inputs: AbiEntry[]): Calldata")),(0,r.kt)("p",null,"Parse the calldata by using input fields from the abi for that method."),(0,r.kt)("h3",{id:"validate"},"validate"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"validateMethodAndArgs(type: 'INVOKE' | 'CALL' | 'DEPLOY', method: string, args: Array<any> = [])")),(0,r.kt)("p",null,"Validates if all arguments that are passed to the method are corresponding to the ones in the abi."))}c.isMDXComponent=!0}}]);