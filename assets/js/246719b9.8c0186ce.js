"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[77815],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(a),d=r,f=u["".concat(l,".").concat(d)]||u[d]||m[d]||s;return a?n.createElement(f,o(o({ref:t},p),{},{components:a})):n.createElement(f,o({ref:t},p))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,o[1]=i;for(var c=2;c<s;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},44561:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const s={sidebar_position:10},o="Estimate fees",i={unversionedId:"guides/estimate_fees",id:"version-5.24.3/guides/estimate_fees",title:"Estimate fees",description:"By default, all nonfree Starknet commands (declare, deploy, invoke) work without any limitation of cost.",source:"@site/versioned_docs/version-5.24.3/guides/estimate_fees.md",sourceDirName:"guides",slug:"/guides/estimate_fees",permalink:"/starknet.js/docs/guides/estimate_fees",draft:!1,tags:[],version:"5.24.3",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"defaultSidebar",previous:{title:"Data transformation",permalink:"/starknet.js/docs/guides/define_call_message"},next:{title:"Work with ERC20 tokens",permalink:"/starknet.js/docs/guides/use_ERC20"}},l={},c=[{value:"estimateDeclareFee",id:"estimatedeclarefee",level:2},{value:"estimateDeployFee",id:"estimatedeployfee",level:2},{value:"estimateAccountDeployFee",id:"estimateaccountdeployfee",level:2},{value:"estimateInvokeFee",id:"estimateinvokefee",level:2},{value:"Fee limitation",id:"fee-limitation",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"estimate-fees"},"Estimate fees"),(0,r.kt)("p",null,"By default, all nonfree Starknet commands (declare, deploy, invoke) work without any limitation of cost."),(0,r.kt)("p",null,"Nevertheless, you might want to inform the DAPP user of the cost of the incoming transaction before proceeding and requesting its validation."),(0,r.kt)("p",null,"Starknet.js proposes several functions to estimate the fees:"),(0,r.kt)("h2",{id:"estimatedeclarefee"},"estimateDeclareFee"),(0,r.kt)("p",null,"To estimate the cost to declare a contract in the network:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const { suggestedMaxFee: estimatedFee1 } = await account0.estimateDeclareFee({\n    contract: compiledTest,\n    classHash: testClassHash\n});\n")),(0,r.kt)("p",null,"The result is in ",(0,r.kt)("inlineCode",{parentName:"p"},"estimatedFee1"),", of type BigInt."),(0,r.kt)("h2",{id:"estimatedeployfee"},"estimateDeployFee"),(0,r.kt)("p",null,"To estimate the cost to deploy a contract in the network:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const { suggestedMaxFee: estimatedFee1 } = await account0.estimateDeployFee({\n    classHash: testClassHash,\n    // constructorCalldata is not necessary if the contract to deploy has no constructor\n    constructorCalldata: callData\n});\n")),(0,r.kt)("p",null,"The result is in ",(0,r.kt)("inlineCode",{parentName:"p"},"estimatedFee1"),", of type BigInt."),(0,r.kt)("h2",{id:"estimateaccountdeployfee"},"estimateAccountDeployFee"),(0,r.kt)("p",null,"To estimate the cost to deploy an account in the network:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const { suggestedMaxFee: estimatedFee1 } = await account0.estimateAccountDeployFee({\n    classHash: OZaccountClashHass,\n    constructorCalldata: OZaccountConstructorCallData,\n    contractAddress: OZcontractAddress\n});\n")),(0,r.kt)("p",null,"The result is in ",(0,r.kt)("inlineCode",{parentName:"p"},"estimatedFee1"),", of type BigInt."),(0,r.kt)("h2",{id:"estimateinvokefee"},"estimateInvokeFee"),(0,r.kt)("p",null,"To estimate the cost to invoke a contract in the network:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const { suggestedMaxFee: estimatedFee1 } = await account0.estimateInvokeFee({\n    contractAddress: testAddress,\n    entrypoint: "increase_balance",\n    calldata: ["10", "30"]\n});\n')),(0,r.kt)("p",null,"The result is in ",(0,r.kt)("inlineCode",{parentName:"p"},"estimatedFee1"),", of type BigInt."),(0,r.kt)("h2",{id:"fee-limitation"},"Fee limitation"),(0,r.kt)("p",null,"In all non-free functions, you can add an optional parameter limiting the fee consumption.",(0,r.kt)("br",{parentName:"p"}),"\n","If the fee has been previously estimated, you can use this value for this parameter, but sometimes this value is under-evaluated: ",(0,r.kt)("strong",{parentName:"p"},"don't hesitate to add a margin of approximately 10%"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"estimatedFee1 * 11n / 10n\n")),(0,r.kt)("p",null,"You can also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"stark.estimatedFeeToMaxFee")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { stark } from "starknet";\nstark.estimatedFeeToMaxFee(estimatedFee1, 0.1);\n')),(0,r.kt)("p",null,"Example for declaring:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const { suggestedMaxFee: estimatedFee1 } = await account0.estimateDeclareFee({ contract: compiledTest });\n\nconst declareResponse = await account0.declare({ contract: compiledTest},\n  { maxFee: estimatedFee1 * 11n / 10n}\n);\n")))}m.isMDXComponent=!0}}]);